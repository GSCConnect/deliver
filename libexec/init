#!/usr/bin/env bash

__version() {
  echo -e "\n${txtbld}deliver v$VERSION${txtrst} | $HOMEPAGE\n"
}

__help() {
  __version

  echo -e "${txtbld}USAGE${txtrst}
  deliver [${txtcyn}CO${txtgrn}MMA${txtred}ND${txtrst}] [${txtylw}MODE${txtrst}]

${txtbld}COMMANDS${txtrst}
  ${txtbld}deliver${txtrst}             Delivers your code to all \$HOSTS
  deliver ${txtgrn}clone${txtrst}*      Creates independent instances of your code across \$HOSTS
  deliver ${txtred}prune${txtrst}*      Keeps \$KEEP most recent code instances across \$HOSTS
  deliver ${txtred}clear${txtrst}*      Clears all traces of your code from \$HOSTS
  deliver ${txtcyn}check${txtrst}       Displays the local deliver configuration (highlights errors)
  deliver ${txtcyn}status${txtrst}*     Displays all code instances across \$HOSTS
  deliver ${txtcyn}strategies${txtrst}  Lists all available strategies
  deliver ${txtcyn}help${txtrst}        This help message
  deliver ${txtcyn}version${txtrst}     Current deliver version

${txtbld}MODES${txtrst}
  Each of the above commands supports the following runtime modes:

  ${txtylw}-C${txtrst}, ${txtylw}--compact${txtrst}   Displays progress, silences output. (default mode)
  ${txtylw}-P${txtrst}, ${txtylw}--plain${txtrst}     Same as compact, but uses no colours (CI friendly)
  ${txtylw}-V${txtrst}, ${txtylw}--verbose${txtrst}   Same as compact, does not silence output
  ${txtylw}-D${txtrst}, ${txtylw}--debug${txtrst}     Shell debug mode

${txtbld}CLONING*${txtrst}
  This command allows you to run 2 (or more) instances of your code side-by-side.

${txtbld}PRUNING*${txtrst}

${txtbld}CLEARING*${txtrst}

${txtbld}STATUS*${txtrst}

${txtbld}MISCELLANEOUS${txtrst}
  You can overwrite any config at runtime. Run ${txtcyn}deliver check${txtrst} to confirm this:

  HOSTS=ruby-1-local PORT=6000 ${txtcyn}deliver check${txtrst}
"
}

__available_strategies() {
  __version

  echo -e "${txtbld}STRATEGIES${txtrst}"

  for strategy in $STRATEGIES_NAME
  do
    echo "  ${txtmgt}$strategy${txtrst}"
  done

  echo ""
}

while (( $# ))
do
  arg="$1" && shift
  case "${arg}" in
# This is inspired by Netflix's approach to HA and some recent blog posts:
# 1. http://blog.phusion.nl/2012/07/26/roadmap-preview-2-live-irb-console-deployment-error-resistance-new-website/
# 2. http://blog.appfog.com/how-to-update-your-appfog-app-with-zero-downtime/
# 3. http://blog.argteam.com/coding/hardening-node-js-for-production-part-3-zero-downtime-deployments-with-nginx/
    (clone)
      CLONE=true
    ;;
    (-h|--help|help)
      __help
      exit 0
    ;;
    (-v|--version|version)
      __version
      exit 0
    ;;
    (-s|--strategies|strategies)
      __available_strategies
      exit 0
    ;;
    (-c|--check|check)
      CHECK=true
    ;;
    (status|prune|clear)
      echo "${arg} has not been implemented yet"
      exit 1
    ;;
    (-C|--compact)
      MODE="compact"
    ;;
    (-D|--debug)
      MODE="debug"
    ;;
    (-V|--verbose)
      MODE="verbose"
    ;;
    (-P|--plain)
      # this was already captured in libexec/output
      # noop
    ;;
    (*)
      hint_message "Unknown argument ${arg} ignored"
    ;;
  esac
done

case "${MODE}" in
  (compact)
    VERBOSE=""
    SILENCE="&> /dev/null"
  ;;
  (verbose)
    VERBOSE=true
    SILENCE=""
  ;;
  (debug)
    set -x
    VERBOSE=true
    SILENCE=""
  ;;
esac
